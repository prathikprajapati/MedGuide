{"ast":null,"code":"import { createMachine, ref } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/presence.connect.ts\nfunction connect(state, send, _normalize) {\n  const present = state.matches(\"mounted\", \"unmountSuspended\");\n  return {\n    skip: !state.context.initial && present,\n    present,\n    setNode(node) {\n      if (!node) return;\n      send({\n        type: \"NODE.SET\",\n        node\n      });\n    },\n    unmount() {\n      send({\n        type: \"UNMOUNT\"\n      });\n    }\n  };\n}\nfunction machine(ctx) {\n  return createMachine({\n    initial: ctx.present ? \"mounted\" : \"unmounted\",\n    context: {\n      node: null,\n      styles: null,\n      unmountAnimationName: null,\n      prevAnimationName: null,\n      present: false,\n      initial: false,\n      ...ctx\n    },\n    exit: [\"clearInitial\"],\n    watch: {\n      present: [\"setInitial\", \"syncPresence\"]\n    },\n    on: {\n      \"NODE.SET\": {\n        actions: [\"setNode\", \"setStyles\"]\n      }\n    },\n    states: {\n      mounted: {\n        on: {\n          UNMOUNT: {\n            target: \"unmounted\",\n            actions: [\"invokeOnExitComplete\"]\n          },\n          \"UNMOUNT.SUSPEND\": \"unmountSuspended\"\n        }\n      },\n      unmountSuspended: {\n        activities: [\"trackAnimationEvents\"],\n        after: {\n          // Fallback to timeout to ensure we exit this state even if the `animationend` event\n          // did not get trigger\n          ANIMATION_DURATION: {\n            target: \"unmounted\",\n            actions: [\"invokeOnExitComplete\"]\n          }\n        },\n        on: {\n          MOUNT: {\n            target: \"mounted\",\n            actions: [\"setPrevAnimationName\"]\n          },\n          UNMOUNT: {\n            target: \"unmounted\",\n            actions: [\"invokeOnExitComplete\"]\n          }\n        }\n      },\n      unmounted: {\n        entry: [\"clearPrevAnimationName\"],\n        on: {\n          MOUNT: {\n            target: \"mounted\",\n            actions: [\"setPrevAnimationName\"]\n          }\n        }\n      }\n    }\n  }, {\n    delays: {\n      ANIMATION_DURATION(ctx2) {\n        return parseMs(ctx2.styles?.animationDuration) + parseMs(ctx2.styles?.animationDelay) + ANIMATION_TIMEOUT_MARGIN;\n      }\n    },\n    actions: {\n      setInitial(ctx2) {\n        ctx2.initial = true;\n      },\n      clearInitial(ctx2) {\n        ctx2.initial = false;\n      },\n      invokeOnExitComplete(ctx2) {\n        ctx2.onExitComplete?.();\n      },\n      setNode(ctx2, evt) {\n        ctx2.node = ref(evt.node);\n      },\n      setStyles(ctx2, evt) {\n        const win = evt.node.ownerDocument.defaultView || window;\n        ctx2.styles = ref(win.getComputedStyle(evt.node));\n      },\n      syncPresence(ctx2, _evt, {\n        send\n      }) {\n        if (ctx2.present) {\n          send({\n            type: \"MOUNT\",\n            src: \"presence.changed\"\n          });\n          return;\n        }\n        if (!ctx2.present && ctx2.node?.ownerDocument.visibilityState === \"hidden\") {\n          send({\n            type: \"UNMOUNT\",\n            src: \"visibilitychange\"\n          });\n          return;\n        }\n        const animationName = getAnimationName(ctx2.styles);\n        const exec = ctx2.immediate ? queueMicrotask : requestAnimationFrame;\n        exec(() => {\n          ctx2.unmountAnimationName = animationName;\n          if (animationName === \"none\" || animationName === ctx2.prevAnimationName || ctx2.styles?.display === \"none\" || ctx2.styles?.animationDuration === \"0s\") {\n            send({\n              type: \"UNMOUNT\",\n              src: \"presence.changed\"\n            });\n          } else {\n            send({\n              type: \"UNMOUNT.SUSPEND\"\n            });\n          }\n        });\n      },\n      setPrevAnimationName(ctx2) {\n        const exec = ctx2.immediate ? queueMicrotask : requestAnimationFrame;\n        exec(() => {\n          ctx2.prevAnimationName = getAnimationName(ctx2.styles);\n        });\n      },\n      clearPrevAnimationName(ctx2) {\n        ctx2.prevAnimationName = null;\n      }\n    },\n    activities: {\n      trackAnimationEvents(ctx2, _evt, {\n        send\n      }) {\n        const node = ctx2.node;\n        if (!node) return;\n        const onStart = event => {\n          const target = event.composedPath?.()?.[0] ?? event.target;\n          if (target === node) {\n            ctx2.prevAnimationName = getAnimationName(ctx2.styles);\n          }\n        };\n        const onEnd = event => {\n          const animationName = getAnimationName(ctx2.styles);\n          const target = event.composedPath?.()?.[0] ?? event.target;\n          if (target === node && animationName === ctx2.unmountAnimationName) {\n            send({\n              type: \"UNMOUNT\",\n              src: \"animationend\"\n            });\n          }\n        };\n        node.addEventListener(\"animationstart\", onStart);\n        node.addEventListener(\"animationcancel\", onEnd);\n        node.addEventListener(\"animationend\", onEnd);\n        return () => {\n          node.removeEventListener(\"animationstart\", onStart);\n          node.removeEventListener(\"animationcancel\", onEnd);\n          node.removeEventListener(\"animationend\", onEnd);\n        };\n      }\n    }\n  });\n}\nfunction getAnimationName(styles) {\n  return styles?.animationName || \"none\";\n}\nfunction parseMs(value) {\n  return parseFloat(value || \"0\") * 1e3;\n}\nvar ANIMATION_TIMEOUT_MARGIN = 16.667;\nvar props = createProps()([\"onExitComplete\", \"present\", \"immediate\"]);\nexport { connect, machine, props };","map":{"version":3,"names":["createMachine","ref","createProps","connect","state","send","_normalize","present","matches","skip","context","initial","setNode","node","type","unmount","machine","ctx","styles","unmountAnimationName","prevAnimationName","exit","watch","on","actions","states","mounted","UNMOUNT","target","unmountSuspended","activities","after","ANIMATION_DURATION","MOUNT","unmounted","entry","delays","ctx2","parseMs","animationDuration","animationDelay","ANIMATION_TIMEOUT_MARGIN","setInitial","clearInitial","invokeOnExitComplete","onExitComplete","evt","setStyles","win","ownerDocument","defaultView","window","getComputedStyle","syncPresence","_evt","src","visibilityState","animationName","getAnimationName","exec","immediate","queueMicrotask","requestAnimationFrame","display","setPrevAnimationName","clearPrevAnimationName","trackAnimationEvents","onStart","event","composedPath","onEnd","addEventListener","removeEventListener","value","parseFloat","props"],"sources":["C:/Users/prath/Documents/Codes/SEM1/Health care startup idea/frontend/node_modules/@zag-js/presence/dist/index.mjs"],"sourcesContent":["import { createMachine, ref } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/presence.connect.ts\nfunction connect(state, send, _normalize) {\n  const present = state.matches(\"mounted\", \"unmountSuspended\");\n  return {\n    skip: !state.context.initial && present,\n    present,\n    setNode(node) {\n      if (!node) return;\n      send({ type: \"NODE.SET\", node });\n    },\n    unmount() {\n      send({ type: \"UNMOUNT\" });\n    }\n  };\n}\nfunction machine(ctx) {\n  return createMachine(\n    {\n      initial: ctx.present ? \"mounted\" : \"unmounted\",\n      context: {\n        node: null,\n        styles: null,\n        unmountAnimationName: null,\n        prevAnimationName: null,\n        present: false,\n        initial: false,\n        ...ctx\n      },\n      exit: [\"clearInitial\"],\n      watch: {\n        present: [\"setInitial\", \"syncPresence\"]\n      },\n      on: {\n        \"NODE.SET\": {\n          actions: [\"setNode\", \"setStyles\"]\n        }\n      },\n      states: {\n        mounted: {\n          on: {\n            UNMOUNT: {\n              target: \"unmounted\",\n              actions: [\"invokeOnExitComplete\"]\n            },\n            \"UNMOUNT.SUSPEND\": \"unmountSuspended\"\n          }\n        },\n        unmountSuspended: {\n          activities: [\"trackAnimationEvents\"],\n          after: {\n            // Fallback to timeout to ensure we exit this state even if the `animationend` event\n            // did not get trigger\n            ANIMATION_DURATION: {\n              target: \"unmounted\",\n              actions: [\"invokeOnExitComplete\"]\n            }\n          },\n          on: {\n            MOUNT: {\n              target: \"mounted\",\n              actions: [\"setPrevAnimationName\"]\n            },\n            UNMOUNT: {\n              target: \"unmounted\",\n              actions: [\"invokeOnExitComplete\"]\n            }\n          }\n        },\n        unmounted: {\n          entry: [\"clearPrevAnimationName\"],\n          on: {\n            MOUNT: {\n              target: \"mounted\",\n              actions: [\"setPrevAnimationName\"]\n            }\n          }\n        }\n      }\n    },\n    {\n      delays: {\n        ANIMATION_DURATION(ctx2) {\n          return parseMs(ctx2.styles?.animationDuration) + parseMs(ctx2.styles?.animationDelay) + ANIMATION_TIMEOUT_MARGIN;\n        }\n      },\n      actions: {\n        setInitial(ctx2) {\n          ctx2.initial = true;\n        },\n        clearInitial(ctx2) {\n          ctx2.initial = false;\n        },\n        invokeOnExitComplete(ctx2) {\n          ctx2.onExitComplete?.();\n        },\n        setNode(ctx2, evt) {\n          ctx2.node = ref(evt.node);\n        },\n        setStyles(ctx2, evt) {\n          const win = evt.node.ownerDocument.defaultView || window;\n          ctx2.styles = ref(win.getComputedStyle(evt.node));\n        },\n        syncPresence(ctx2, _evt, { send }) {\n          if (ctx2.present) {\n            send({ type: \"MOUNT\", src: \"presence.changed\" });\n            return;\n          }\n          if (!ctx2.present && ctx2.node?.ownerDocument.visibilityState === \"hidden\") {\n            send({ type: \"UNMOUNT\", src: \"visibilitychange\" });\n            return;\n          }\n          const animationName = getAnimationName(ctx2.styles);\n          const exec = ctx2.immediate ? queueMicrotask : requestAnimationFrame;\n          exec(() => {\n            ctx2.unmountAnimationName = animationName;\n            if (animationName === \"none\" || animationName === ctx2.prevAnimationName || ctx2.styles?.display === \"none\" || ctx2.styles?.animationDuration === \"0s\") {\n              send({ type: \"UNMOUNT\", src: \"presence.changed\" });\n            } else {\n              send({ type: \"UNMOUNT.SUSPEND\" });\n            }\n          });\n        },\n        setPrevAnimationName(ctx2) {\n          const exec = ctx2.immediate ? queueMicrotask : requestAnimationFrame;\n          exec(() => {\n            ctx2.prevAnimationName = getAnimationName(ctx2.styles);\n          });\n        },\n        clearPrevAnimationName(ctx2) {\n          ctx2.prevAnimationName = null;\n        }\n      },\n      activities: {\n        trackAnimationEvents(ctx2, _evt, { send }) {\n          const node = ctx2.node;\n          if (!node) return;\n          const onStart = (event) => {\n            const target = event.composedPath?.()?.[0] ?? event.target;\n            if (target === node) {\n              ctx2.prevAnimationName = getAnimationName(ctx2.styles);\n            }\n          };\n          const onEnd = (event) => {\n            const animationName = getAnimationName(ctx2.styles);\n            const target = event.composedPath?.()?.[0] ?? event.target;\n            if (target === node && animationName === ctx2.unmountAnimationName) {\n              send({ type: \"UNMOUNT\", src: \"animationend\" });\n            }\n          };\n          node.addEventListener(\"animationstart\", onStart);\n          node.addEventListener(\"animationcancel\", onEnd);\n          node.addEventListener(\"animationend\", onEnd);\n          return () => {\n            node.removeEventListener(\"animationstart\", onStart);\n            node.removeEventListener(\"animationcancel\", onEnd);\n            node.removeEventListener(\"animationend\", onEnd);\n          };\n        }\n      }\n    }\n  );\n}\nfunction getAnimationName(styles) {\n  return styles?.animationName || \"none\";\n}\nfunction parseMs(value) {\n  return parseFloat(value || \"0\") * 1e3;\n}\nvar ANIMATION_TIMEOUT_MARGIN = 16.667;\nvar props = createProps()([\"onExitComplete\", \"present\", \"immediate\"]);\n\nexport { connect, machine, props };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}